# 12강 병렬 스트림
### 📝 김영한 실전 자바 고급편 3 - 강의 정리 노트

하나의 메인 스레드로 작업하면 실행 시간이 너무 오래 걸리게 된다.<br>
따라서 여러 스레드를 동시에 사용해서 작업을 더 빨리 처리해보도록 하자

## 스레드 풀 사용
```java
        ExecutorService es = Executors.newFixedThreadPool(2);
        long startTime = System.currentTimeMillis();

        // 1. 작업을 분할한다.
        SumTask task1 = new SumTask(1, 4);
        SumTask task2 = new SumTask(5, 8);

        // 2. 분할한 작업을 처리한다.
        Future<Integer> future1 = es.submit(task1);
        Future<Integer> future2 = es.submit(task2);

        //3. join - 처리한 결과를 합침, get - 결과가 나올 떄까지 대기
        Integer result1 = future1.get();
        Integer result2 = future2.get();

        int sum = result1 + result2;
        long endTime = System.currentTimeMillis();
        log("time: " + (endTime - startTime) + "ms, sum: " + sum);
        es.shutdown(); // 자바 19+부터 es.close()가 가능하다고 한다..
```

1. Executors.newFixedThreadPool(2)는
최대 2개의 스레드를 제공하는 스레드 풀을 만든다.

```java
    static class SumTask implements Callable<Integer> {
        int startValue;
        int endValue;

        public SumTask(int startValue, int endValue) {
            this.startValue = startValue;
            this.endValue = endValue;
        }

        @Override
        public Integer call() {
            log("작업 시작");
            int sum = 0;
            for (int i = startValue; i <= endValue; i++) {
                int calculated = HeavyJob.heavyTask(i);
                sum += calculated;
            }
            log("작업 완료 result: " + sum);
            return sum;
        }
    }
```
2. `SumTask` 메서드를 이용해서 작업을 두개로 분할한다.
3. 스레드풀의 `submit`메서드를 통해 스레드 풀 적업을 맡겨 Future 객체를 받고
4. 실제 결과가 나올때까지 대기한다.

여러 스레드를 통해 실행시간이 더 단축되고 `Future`로 반환값을 쉽게 받아올 수 있다.
하지만 분할/병합 로직을 직접 짜야하는 단점이 있다

---

## Fork/join 패턴

지금까지는 개발자가 작업을 직접 분할하고 처리하고 처리된 결과를 합쳤다
하지만 자바에서 Fork/Join 프레임워크를 통해 위 패턴을 더 쉽게 구현할 수 있다.

```java
public class ForkJoinMain1 {
    public static void main(String[] args) {
        List<Integer> data = IntStream.rangeClosed(1, 8)
                .boxed()
                .toList();
        log("[생성]" + data);

        //forkJoinPool 생성 및 작업 수행
        long startTime = System.currentTimeMillis();
        ForkJoinPool pool = new ForkJoinPool(10);
        SumTask task = new SumTask(data); //1-8

        //병렬로 합을 구한 후 결과 출력
        Integer result = pool.invoke(task);
        pool.shutdown();
        long endTime = System.currentTimeMillis();
        log("time: " + (endTime - startTime) + "ms, sum: " + result);
        log("pool: " + pool);
    }
}
```
ForkJoinPool을 생성해서 최대 10의 스레드를 사용할 수 있는 스레드 풀을 생성한다.
pool.invoke(task)를 통해 SumTask를 스레드 풀에 전달해서 병렬 실행을 시작한다.

```java
    @Override
    protected Integer compute() {
        //작업 범위가 작으면 직접 확산
        if (list.size() <= THRESHOLD) {
            log("[처리 시작]" + list);
            int sum = list.stream()
                    .mapToInt(Integer::intValue)
                    .sum();
            log("[처리 완료]" + list + "-> sum: " + sum);
            return sum;
        } else {
            //작업 범위가 크면 반으로 나누어 병렬 처리
            int mid = list.size() / 2;
            List<Integer> leftList = list.subList(0, mid);
            List<Integer> rightLIst = list.subList(mid, list.size());
            log("[분할]" + list + "-> LEFT: " + leftList + ", RIGHT: " + rightLIst);

            SumTask leftTask = new SumTask(leftList);
            SumTask rightTask = new SumTask(rightLIst);

            //왼쪽 작업은 다른 스레드에서 처리
            leftTask.fork();
            // 오른쪽 작업은 현제 스레드에서 처리
            int rightResult = rightTask.compute();

            //왼쪽 작업 결과를 기다림
            int leftResult = leftTask.join();
            //왼쪽과 오른쪽 작업 결과 합침
            int joinSum = leftResult + rightResult;
            log("LEFT[" + leftResult + "] RIGHT[" + rightResult + "] joinSum: " + joinSum);
            return joinSum;
        }
    }
```
즉, `SumTask` 클래스에서 `compute()` 내부에서 작업의 로직을 정의하고,
`ForkJoinMain1` 클래스 내부에서 `invoke()`를 통해 실제 작업 실행 과정으로 진행된다.

---

## Fork/Join 프레임워크 - 공용 풀
공용 풀(common pool)은 `Fork/Join` 작업을 위해 자바가 제공하는 스레드 풀이다.

```java
List<Integer> data  = IntStream.rangeClosed(1, 8)
                        .boxed()
                        .toList();

SumTask task =  new SumTask(data);
Integer result = task.invoke(); //공용 풀 사용
```
이전에 `ForkJoinPool` 인스턴스를 생성해 `pool.invoke(take)`를 통해 풀에 직접 작업을 요청해야 하지만
공용풀을 사용하면 별도의 인스턴스를 생성하지 않아도 자바가 공용풀을 사용해 병렬 처리를 하게 도와준다.
공용풀은 JVM이 종료될 때까지 유지되기 때문에 별도로 풀을 종료하지 않아도 된다.

### Fork/Join 공용 풀의 특징
- 시스템 전체에서 공유 
    - 애플리케이션 내 단일 인스턴스로 공유됨
- 자동 생성과 편리한 사용
    - 별도로 생성 x, ForkJoinPool.commonPool()를 통해 접근 가능
- 병렬 스트림 활용
    - 자바 8의 병렬 스트림은 내부적으로 공용 풀 사용
- 자원 효율성 
    - 여러 곳에서 별도 풀을 생성하는 대신에 공용 풀을 사용해 자원을 효율적으로 관리
- 병렬 수준 자동 설정
    - 시스템의 가용 프로세서 수에서 1을 뺀 값으로 병렬 수준이 설정됨

---

## 공용 풀 vs 커스텀 풀

### 커스텀 Fork/Join 풀
```java
ForkJoinPool pool = new ForkJoinPool();
Integer result = pool.invoke(task);
```

### 공용 풀
```java
Integer result = task.invoke();
```
커스텀 풀과 공용 풀의 차이점은 무엇일까?

### 차이점 
1. 자원관리 
- 커스텀 풀은 명시적으로 생성하고 관리, 공용풀은 시스템에서 자동 관리
2. 재사용성 
- 공용 풀은 여러곳에서 공유 가능, 커스텀 풀은 x
3. 설정 제어
- 커스텀 풀은 병렬수준과 스레드 팩토리 등 세부 제어 가능, 공용 풀은 기본 설정 사용
4. 라이프사이클 
- 커스텀 풀은 명시적으로 종료, 공용풀은 JVM이 관리함으로 명시적으로 종료하지 않아도 됨.

---

## 자바 병렬 스트림
```java
int sum = IntStream.rangeClosed(1, 8)
            .parallel() //추가
            .map(HeavyJob::heavyTask)
            .reduce(0, (a, b) -> a + b);//sum()
```
직접 스레드를 만들 필요 없이 parallel() 메서드만 호출하면 스트림이 자동으로 병렬 처리된다.
따라서  parallel() 선언을 통해 복잡한 멀티스레드 코드 없이 스트림을 병렬로 쉽게 처리할 수 있다.

---

## 병렬 스트림 사용시 주의점
parallel()를 사용한 병렬 스트림은 스레드가 주로 대기해야 하는 I/O 바운드 작업에는 적합하지 않다.
병렬스트림은 기본저긍로 CPU 코어 수에 맞춰 스레드가 할당되기에 연산이 많은 CPU 바운드 작업에서 성능 이점을 볼 수 있다.
공용풀은 별도의 풀 생성 없이 효율적인 병렬 처리가 가능하지만 블로킹 작업이나 특수한 설정이 필요할 경우에는
커스텀 풀을 고려해야 한다.

> 실무에서 공용 풀은 절대 I/O 바운드 작업 xxxx
> 공용 풀을 통해 외부 API 호출이나 데이터베이스를 호출하고 기다리는 경우, 
> 외부 API나 데이터베이스 응답이 늦게 온다면 공용 풀 내 스레드 모두 I/O 응답을 대기하게 된다.
> 즉, 모든 요청이 공용 풀의 스레드를 기다리며 작업이 다 대기되어 밀리게 된다!!


---

## 별도의 풀 사용
i/o 바운드 작업처러 대기가 긴 경우 전용 스레드 풀을 만들어 사용하는 것이 권장된다.

```java
    public static void main(String[] args) throws InterruptedException {

        //요청 풀 추가
        ExecutorService requestPool = Executors.newFixedThreadPool(100);

        //logic 처리 전용 스레드 풀 추가
        ExecutorService logicPool = Executors.newFixedThreadPool(400);

        int nThreads = 3;
        for (int i = 0; i < nThreads; i++) {
            String requestName = "request" + i;
            requestPool.submit(() -> logic(requestName, logicPool));
            Thread.sleep(100);
        }
        requestPool.shutdown();
        logicPool.shutdown();
    }
```
최대 400개의 스레드를 가진 별도 로직을 처리하는 전용 스레드를 추가해서 병렬 작업 처리를 하는 코드이다.
```java
    private static void logic(String requestName, ExecutorService es) {
        log("[" + requestName + "] start");
        long startTime = System.currentTimeMillis();

        List<Future<Integer>> futures = IntStream.range(1, 4)
                .mapToObj(i -> es.submit(() -> HeavyJob.heavyTask(i, requestName)))
                .toList();

        int sum = futures.stream()
                .mapToInt(f -> {
                    try {
                        return f.get();
                    } catch (Exception e) {
                        throw new RuntimeException(e);
                    }
                }).sum();

        long endTime = System.currentTimeMillis();
        log("[" + requestName + "] time: " + (endTime - startTime) + "ms, sum : " + sum);
    }
```
이렇게 전용 스레드 풀을 만들어 처리하면 요청별 처리 시간이 지연되는 문제를 해결할 수 있고,
동시에 여러 요청을 효율적으로 처리해 공용 풀 병목 현상을 막을 수 있다.

---

## 주의 사항
병렬 스트림은 처음부터 Fork/Join 공용 풀과 함께 사용하도록 설계되었기 때문에
반드시 CPU 바운드 작업에서 사용되어야 한다.
