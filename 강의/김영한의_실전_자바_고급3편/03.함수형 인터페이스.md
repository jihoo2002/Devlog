# 3강 함수형 인터페이스

### 📝 김영한 실전 자바 고급편 3 - 강의 정리 노트

```java
public static void main(String[] args) {
    //함수형 인터페이스
    StringFunction upperCase = s -> s.toUpperCase();
    String result1 = upperCase.apply("hello");
    System.out.println("result1 = " + result1);

    NumberFunction square = n -> n * n;
    Integer result2 = square.apply(5);
    System.out.println("result2 = " + result2);
}

@FunctionalInterface
interface StringFunction {
    String apply(String s);
}

@FunctionalInterface
interface NumberFunction {
    Integer apply(Integer n);
}
```

매개변수와 반환타입이 다를 때마다 함수형 인터페이스를 계속해서 만들어야 하는
복잡함이 존재한다.</br>
어떻게 해결할 수 있을까?

## Object 사용?

```java
@FunctionalInterface
interface ObjectFunction {
    Object apply(Object s);
}
```
첫번째 방법은 매개변수와 반환타입 모두를 Object로 명시하면
함수형 인터페이스를 계속 만들지 않고도 쓸 수 있다.

```java
public static void main(String[] args) {
    //타입을 오브젝트로
    ObjectFunction upperCase = s -> ((String) s).toUpperCase();
    String result1 = (String) upperCase.apply("hello");

    ObjectFunction square = n -> (Integer) n * (Integer) n;
    Integer result2 = (Integer) square.apply(5);
}
```
하지만 Object를 사용하기 때문에 계속해서 타입 다운 캐스팅을 해야하는 불편함이 있고
또 타입 안전성 문제 또한 무시할 수 없다.

## 제네릭 도입하기
```java
    @FunctionalInterface
    interface GenericFunction<T, R> {
        R apply(T s);
    }
```
메개변수의 타입을 `T`, 반환타입을 `R`로 지정한 제네릭을 통해
아래와 같이 매개변수와 반환타입을 유연하게 변경가능하다.
```java
public static void main(String[] args) {
    //매개변수 타입 String, 반환타입 String
    GenericFunction<String, String> upperCase = new GenericFunction<>() {
        @Override
        public String apply(String s) {
            return s.toUpperCase();
        }
    };
    String result1 = upperCase.apply("hello");
    System.out.println("result1 = " + result1);

    //람다 표현식으로 간추리면 !
    GenericFunction<Integer, Integer> square = n -> n * n;

    Integer result2 = square.apply(5);
    System.out.println("result2 = " + result2);
}
```






